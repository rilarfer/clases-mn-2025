{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenido","text":"<p>Este sitio contiene ejemplos y c\u00f3digos del curso de M\u00e9todos Num\u00e9ricos 2025.</p>"},{"location":"#codigos-disponibles","title":"C\u00f3digos disponibles","text":"<ul> <li>Newton-Raphson</li> <li>Iteraci\u00f3n Simple</li> <li>Jacobiano</li> </ul> <p>Puedes verlos en la secci\u00f3n \"C\u00f3digos\" del men\u00fa.</p>"},{"location":"jacobian/","title":"Funci\u00f3n Jacobian","text":"jacobian.m<pre><code>function [jac, f0] = jacobian(func, x)\n% Calcula la matriz Jacobiana y el vector f(x) en el punto x.\n% USO:\n%   [jac, f0] = jacobian(func, x)\n% ENTRADAS:\n%   func - funci\u00f3n manejable que devuelve el vector f(x)\n%   x    - vector columna de variables [x1; x2; ...; xn]\n% SALIDAS:\n%   jac - matriz Jacobiana (n x n) aproximada por diferencias finitas\n%   f0  - evaluaci\u00f3n de f(x) en el punto actual\n\nh = 1.0e-4;                         % Incremento para diferencia finita\nn = length(x);                     % N\u00famero de variables\njac = zeros(n);                    % Inicializa matriz Jacobiana\nf0 = feval(func, x);               % Eval\u00faa f(x) en el punto actual\n\nfor i = 1:n\n    temp = x(i);                   % Guarda el valor original de x(i)\n    x(i) = temp + h;               % Perturba x(i)\n    f1 = feval(func, x);           % Eval\u00faa f(x + h)\n    x(i) = temp;                   % Restaura el valor original\n    jac(:, i) = (f1 - f0) / h;     % Aproxima derivada parcial\nend\nend\n</code></pre>"},{"location":"newtonRaphson_segura/","title":"Newton-Raphson Segura","text":"newtonRaphson_segura.m<pre><code>function root = newtonRaphson_segura(func, dfunc, a, b, tol)\n% M\u00e9todo de Newton-Raphson combinado con bisecci\u00f3n para encontrar una ra\u00edz de f(x) = 0.\n% USO:\n%   root = newtonRaphson_segura(func, dfunc, a, b, tol)\n% ENTRADAS:\n%   func  - funci\u00f3n manejable que eval\u00faa f(x)\n%   dfunc - funci\u00f3n manejable que eval\u00faa f'(x)\n%   a, b  - extremos del intervalo que encierra la ra\u00edz\n%   tol   - tolerancia de error (opcional, por defecto es 1.0e6 * eps)\n% SALIDA:\n%   root - ra\u00edz encontrada (o NaN si no hay convergencia)\n\nif nargin &lt; 5; tol = 1.0e6 * eps; end           % Tolerancia por defecto\nfa = feval(func, a); fb = feval(func, b);       % Evaluar extremos del intervalo\n\n% Verifica si alguno de los extremos ya es ra\u00edz\nif fa == 0; root = a; return\nelseif fb == 0; root = b; return\nend\n\n% Verifica que la ra\u00edz est\u00e9 encerrada\nif fa * fb &gt; 0\n    error('La ra\u00edz no est\u00e1 encerrada en (a, b)')\nend\n\nx = (a + b) / 2;                       % Punto inicial: punto medio\n\nfor i = 1:30\n    fx = feval(func, x);               % Evaluar f(x)\n    if abs(fx) &lt; tol                   % Verifica si ya encontr\u00f3 la ra\u00edz\n        root = x; return\n    end\n\n    % Ajuste del intervalo usando bisecci\u00f3n\n    if fa * fx &lt; 0\n        b = x; fb = fx;\n    else\n        a = x; fa = fx;\n    end\n\n    dfx = feval(dfunc, x);             % Evaluar f'(x)\n    if abs(dfx) == 0                   % Evitar divisi\u00f3n por cero\n        dx = b - a;\n    else\n        dx = -fx / dfx;                % Paso de Newton-Raphson\n    end\n\n    x = x + dx;                        % Nueva estimaci\u00f3n\n\n    % Si la estimaci\u00f3n sale del intervalo, usar bisecci\u00f3n\n    if (x &lt; a) || (x &gt; b)\n        dx = (b - a) / 2;\n        x = a + dx;\n    end\n\n    % Verificaci\u00f3n de convergencia\n    if abs(dx) &lt; tol * max(abs(b), 1.0)\n        root = x; return\n    end\nend\n\nroot = NaN;                            % Si no converge en 30 iteraciones\nend\n</code></pre>"},{"location":"newtonRaphson_sistema/","title":"Newton-Raphson para Sistemas de Ecuaciones","text":"newtonRaphson_sistema.m<pre><code>function root = newtonRaphson_sistema(func, x, tol)\n% M\u00e9todo de Newton-Raphson para encontrar la ra\u00edz de un sistema de\n% ecuaciones no lineales: f_i(x_1,x_2,...,x_n) = 0, para i = 1,2,...,n.\n% USO:\n%   root = newtonRaphson_sistema(func, x, tol)\n% ENTRADAS:\n%   func - funci\u00f3n manejable que retorna el vector [f1, f2, ..., fn]\n%   x    - vector columna con la estimaci\u00f3n inicial [x1; x2; ...; xn]\n%   tol  - tolerancia al error (opcional, por defecto 1.0e4 * eps)\n% SALIDA:\n%   root - vector soluci\u00f3n (aproximaci\u00f3n de la ra\u00edz)\nif nargin == 2; tol = 1.0e4 * eps; end             % Tolerancia por defecto\nif size(x,1) == 1; x = x'; end                     % Asegura que x sea columna\nfor i = 1:30                                       % M\u00e1ximo 30 iteraciones\n    [jac, f0] = jacobian(func, x);                % Calcula Jacobiana y f(x)\n    % Criterio de convergencia por magnitud de f(x)\n    if sqrt(dot(f0, f0) / length(x)) &lt; tol\n        root = x;\n        return\n    end\n    dx = jac \\ (-f0);                             % Resuelve J dx = -f\n    x = x + dx;                                   % Actualiza soluci\u00f3n\n    % Criterio de convergencia por cambio en x\n    if sqrt(dot(dx, dx) / length(x)) &lt; tol * max(abs(x), 1.0)\n        root = x;\n        return\n    end\nend\nerror('Muchas iteraciones: el m\u00e9todo no convergi\u00f3.');\nend\n</code></pre>"},{"location":"newton_simple/","title":"Newton-Raphson Simple","text":"newton_simple.m<pre><code>function [root, numIter] = newton_simple(func, dfunc, x, tol)\n% Versi\u00f3n simple del m\u00e9todo de Newton-Raphson.\n% USO:\n%   [root, numIter] = newton_simple(func, dfunc, x, tol)\n% ENTRADAS:\n%   func  - funci\u00f3n manejable que eval\u00faa f(x)\n%   dfunc - funci\u00f3n manejable que eval\u00faa f'(x)\n%   x     - valor inicial (x0)\n%   tol   - tolerancia al error (opcional, por defecto 1.0e6*eps)\n% SALIDAS:\n%   root     - aproximaci\u00f3n de la ra\u00edz\n%   numIter  - n\u00famero de iteraciones realizadas\n\nif nargin &lt; 4; tol = 1.0e6 * eps; end    % Establecer tolerancia por defecto\nnumIter = 0;\nfor i = 1:50                   % M\u00e1ximo de 50 iteraciones\n    fx = feval(func, x);      % Evaluar funci\u00f3n\n    dfx = feval(dfunc, x);    % Evaluar derivada\n    if dfx == 0               % Evita divisi\u00f3n por cero\n        root = NaN; return\n    end\n    dx = -fx / dfx;           % Paso de Newton\n    x = x + dx;               % Actualiza estimaci\u00f3n\n    if abs(dx) &lt; tol          % Criterio de convergencia\n        root = x; numIter = i; return\n    end\nend\nroot = NaN;                   % No convergi\u00f3 en 50 iteraciones\nend\n</code></pre>"}]}