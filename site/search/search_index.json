{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenido","text":"<p>Este sitio contiene ejemplos y c\u00f3digos del curso de M\u00e9todos Num\u00e9ricos 2025.</p>"},{"location":"#nuevos-codigos-clase-18","title":"\ud83c\udd95 Nuevos c\u00f3digos (Clase 18):","text":"<ul> <li>Eliminaci\u00f3n de Gauss (<code>gauss</code>)</li> <li>Descomposici\u00f3n LU (<code>LUdec</code>)</li> <li>Fase de Soluci\u00f3n LU (<code>LUsol</code>)</li> <li>Descomposici\u00f3n de Choleski (<code>choleski</code>)</li> </ul>"},{"location":"#asignacion","title":"\ud83d\udccc Asignaci\u00f3n","text":"<p>Ya se encuentra disponible la secci\u00f3n de problemas propuestos para esta unidad. Pueden acceder desde el men\u00fa lateral o directamente haciendo clic aqu\u00ed:</p> <p>\ud83d\udc49 Ir a la Asignaci\u00f3n</p> <p>\ud83d\udca1 Recuerda que los ejercicios deben resolverse utilizando los m\u00e9todos y funciones vistas en clase. Las soluciones ser\u00e1n revisadas considerando precisi\u00f3n y organizaci\u00f3n del c\u00f3digo.</p>"},{"location":"#documento-de-clase","title":"\ud83d\udcc4 Documento de Clase","text":"Tu navegador no admite iframes.     Puedes ver el documento directamente haciendo clic    aqu\u00ed."},{"location":"LUdec/","title":"Descomposici\u00f3n LU \u2014 Doolittle","text":"<p>Esta funci\u00f3n realiza la descomposici\u00f3n LU de una matriz \\(\\mathbf{A}\\) sin pivoteo, sobrescribi\u00e9ndola con la forma [L\\U].</p>"},{"location":"LUdec/#codigo","title":"C\u00f3digo","text":"<pre><code>function A = LUdec(A)\n% LU decomposition of matrix A; returns A = [L\\U]\n% USO: A = LUdec(A)\n\nn = size(A, 1);\n\nfor k = 1:n-1\n    for i = k+1:n\n        if A(i,k) ~= 0.0\n            lambda = A(i,k) / A(k,k);\n            A(i,k+1:n) = A(i,k+1:n) - lambda * A(k,k+1:n);\n            A(i,k) = lambda;\n        end\n    end\nend\n</code></pre> <p>\u2b60 Volver al inicio</p>"},{"location":"LUsol/","title":"Fase de Soluci\u00f3n LU","text":"<p>Esta funci\u00f3n resuelve \\(\\mathbf{LUx} = \\mathbf{b}\\) usando sustituci\u00f3n hacia adelante y hacia atr\u00e1s. La matriz <code>A</code> contiene [L\\U].</p>"},{"location":"LUsol/#codigo","title":"C\u00f3digo","text":"<pre><code>function x = LUsol(A, b)\n% Soluci\u00f3n del sistema LUx = b\n\nn = length(b);\n\n% Sustituci\u00f3n hacia adelante (Ly = b)\nfor k = 2:n\n    b(k) = b(k) - A(k,1:k-1) * b(1:k-1);\nend\n\n% Sustituci\u00f3n hacia atr\u00e1s (Ux = y)\nfor k = n:-1:1\n    b(k) = (b(k) - A(k,k+1:n) * b(k+1:n)) / A(k,k);\nend\n\nx = b;\nend\n</code></pre> <p>\u2b60 Volver al inicio</p>"},{"location":"asignacion/","title":"Problemas Propuestos","text":""},{"location":"asignacion/#1-gauss-con-multiples-vectores-constantes","title":"1. Gauss con m\u00faltiples vectores constantes","text":"<p>Modifique la funci\u00f3n <code>gauss</code> para que funcione con \\(m\\) vectores constantes. Pruebe el programa resolviendo \\(\\mathbf{AX} = \\mathbf{B}\\), donde:</p> \\[ \\mathbf{A} = \\begin{bmatrix} 2 &amp; -1 &amp; 0 \\\\ -1 &amp; 2 &amp; -1 \\\\ 0 &amp; -1 &amp; 1 \\end{bmatrix}, \\quad \\mathbf{B} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} \\]"},{"location":"asignacion/#2-matriz-de-hilbert","title":"2. Matriz de Hilbert","text":"<p>Un ejemplo conocido de una matriz mal condicionada es la matriz de Hilbert:</p> \\[ \\mathbf{A} = \\begin{bmatrix} 1 &amp; \\tfrac{1}{2} &amp; \\tfrac{1}{3} &amp; \\cdots \\\\ \\tfrac{1}{2} &amp; \\tfrac{1}{3} &amp; \\tfrac{1}{4} &amp; \\cdots \\\\ \\tfrac{1}{3} &amp; \\tfrac{1}{4} &amp; \\tfrac{1}{5} &amp; \\cdots \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots \\end{bmatrix} \\] <p>Escriba un programa que resuelva \\(\\mathbf{Ax} = \\mathbf{b}\\) mediante el m\u00e9todo de Doolittle, donde \\(\\mathbf{A}\\) es una matriz de Hilbert de tama\u00f1o \\(n \\times n\\) y:</p> \\[ b_i = \\sum_{j=1}^{n} A_{ij} \\] <p>El programa no debe tener entrada aparte de \\(n\\). Determine el valor m\u00e1ximo de \\(n\\) para el cual la soluci\u00f3n est\u00e9 dentro de 6 cifras significativas de:</p> \\[ \\mathbf{x} = \\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \\cdots \\end{bmatrix}^T \\]"},{"location":"asignacion/#3-solucion-con-choleski","title":"3. Soluci\u00f3n con Choleski","text":"<p>Escriba una funci\u00f3n para la fase de soluci\u00f3n del m\u00e9todo de descomposici\u00f3n de Choleski. Pruebe la funci\u00f3n resolviendo \\(\\mathbf{Ax} = \\mathbf{b}\\), donde:</p> \\[ \\mathbf{A} = \\begin{bmatrix} 4 &amp; -2 &amp; 2 \\\\ -2 &amp; 2 &amp; -4 \\\\ 2 &amp; -4 &amp; 11 \\end{bmatrix}, \\quad \\mathbf{b} = \\begin{bmatrix} 6 \\\\ -10 \\\\ 27 \\end{bmatrix} \\] <p>Use la funci\u00f3n <code>choleski</code> para la fase de descomposici\u00f3n.</p>"},{"location":"asignacion/#4-precision-numerica","title":"4. Precisi\u00f3n Num\u00e9rica","text":"<p>Resuelva el sistema \\(\\mathbf{Ax} = \\mathbf{b}\\), donde:</p> \\[ \\mathbf{A} = \\begin{bmatrix} 3.50 &amp; 2.77 &amp; -0.76 &amp; 1.80 \\\\ -1.80 &amp; 2.68 &amp; 3.44 &amp; -0.09 \\\\ 0.27 &amp; 5.07 &amp; 6.90 &amp; 1.61 \\\\ 1.71 &amp; 5.45 &amp; 2.68 &amp; 1.71 \\end{bmatrix}, \\quad \\mathbf{b} = \\begin{bmatrix} 7.31 \\\\ 4.23 \\\\ 13.85 \\\\ 11.55 \\end{bmatrix} \\] <p>Calcule \\(|\\mathbf{A}|\\) y \\(\\mathbf{Ax}\\) y comente sobre la precisi\u00f3n de la soluci\u00f3n.</p> <p>\u2190 Volver al inicio</p>"},{"location":"choleski/","title":"Descomposici\u00f3n de Choleski","text":"<p>Esta funci\u00f3n realiza la descomposici\u00f3n \\(\\mathbf{A} = \\mathbf{L}\\mathbf{L}^T\\) para matrices sim\u00e9tricas definidas positivas.</p>"},{"location":"choleski/#codigo","title":"C\u00f3digo","text":"<pre><code>function L = choleski(A)\n% Descomposici\u00f3n de Choleski: A = L*L'\n\nn = size(A, 1);\n\nfor j = 1:n\n    temp = A(j,j) - dot(A(j,1:j-1), A(j,1:j-1));\n\n    if temp &lt; 0.0\n        error('Matrix is not positive definite');\n    end\n\n    A(j,j) = sqrt(temp);\n\n    for i = j+1:n\n        A(i,j) = (A(i,j) - dot(A(i,1:j-1), A(j,1:j-1))) / A(j,j);\n    end\nend\n\nL = tril(A);\nend\n</code></pre> <p>\u2b60 Volver al inicio</p>"},{"location":"gauss/","title":"Eliminaci\u00f3n de Gauss","text":"<p>Esta funci\u00f3n resuelve un sistema de ecuaciones lineales \\(\\mathbf{Ax} = \\mathbf{b}\\) utilizando el m\u00e9todo de eliminaci\u00f3n de Gauss con sustituci\u00f3n hacia atr\u00e1s.</p>"},{"location":"gauss/#codigo","title":"C\u00f3digo","text":"<pre><code>function [x, determinante] = gauss(A, b)\n% Resuelve A*x = b usando eliminaci\u00f3n de Gauss y calcula det(A)\n% USO: [x, determinante] = gauss(A, b)\n\n% Asegurar que b sea un vector columna\nif size(b, 2) &gt; 1\n    b = b';\nend\n\nn = length(b);\n\n% -------------------------------\n% Fase de eliminaci\u00f3n\n% -------------------------------\nfor k = 1:n-1\n    for i = k+1:n\n        if A(i,k) ~= 0\n            lambda = A(i,k) / A(k,k);\n            A(i,k+1:n) = A(i,k+1:n) - lambda * A(k,k+1:n);\n            b(i) = b(i) - lambda * b(k);\n        end\n    end\nend\n\n% C\u00e1lculo del determinante si se solicita\nif nargout == 2\n    determinante = prod(diag(A));\nend\n\n% -------------------------------\n% Fase de sustituci\u00f3n hacia atr\u00e1s\n% -------------------------------\nfor k = n:-1:1\n    b(k) = (b(k) - A(k,k+1:n) * b(k+1:n)) / A(k,k);\nend\n\nx = b;\nend\n</code></pre> <p>\u2b60 Volver al inicio</p>"},{"location":"jacobian/","title":"Funci\u00f3n Jacobian","text":"jacobian.m<pre><code>function [jac, f0] = jacobian(func, x)\n% Calcula la matriz Jacobiana y el vector f(x) en el punto x.\n% USO:\n%   [jac, f0] = jacobian(func, x)\n% ENTRADAS:\n%   func - funci\u00f3n manejable que devuelve el vector f(x)\n%   x    - vector columna de variables [x1; x2; ...; xn]\n% SALIDAS:\n%   jac - matriz Jacobiana (n x n) aproximada por diferencias finitas\n%   f0  - evaluaci\u00f3n de f(x) en el punto actual\n\nh = 1.0e-4;                         % Incremento para diferencia finita\nn = length(x);                     % N\u00famero de variables\njac = zeros(n);                    % Inicializa matriz Jacobiana\nf0 = feval(func, x);               % Eval\u00faa f(x) en el punto actual\n\nfor i = 1:n\n    temp = x(i);                   % Guarda el valor original de x(i)\n    x(i) = temp + h;               % Perturba x(i)\n    f1 = feval(func, x);           % Eval\u00faa f(x + h)\n    x(i) = temp;                   % Restaura el valor original\n    jac(:, i) = (f1 - f0) / h;     % Aproxima derivada parcial\nend\nend\n</code></pre> <p>\u2b60 Volver al inicio</p>"},{"location":"newtonRaphson_segura/","title":"Newton-Raphson Segura","text":"newtonRaphson_segura.m<pre><code>function root = newtonRaphson_segura(func, dfunc, a, b, tol)\n% M\u00e9todo de Newton-Raphson combinado con bisecci\u00f3n para encontrar una ra\u00edz de f(x) = 0.\n% USO:\n%   root = newtonRaphson_segura(func, dfunc, a, b, tol)\n% ENTRADAS:\n%   func  - funci\u00f3n manejable que eval\u00faa f(x)\n%   dfunc - funci\u00f3n manejable que eval\u00faa f'(x)\n%   a, b  - extremos del intervalo que encierra la ra\u00edz\n%   tol   - tolerancia de error (opcional, por defecto es 1.0e6 * eps)\n% SALIDA:\n%   root - ra\u00edz encontrada (o NaN si no hay convergencia)\n\nif nargin &lt; 5; tol = 1.0e6 * eps; end           % Tolerancia por defecto\nfa = feval(func, a); fb = feval(func, b);       % Evaluar extremos del intervalo\n\n% Verifica si alguno de los extremos ya es ra\u00edz\nif fa == 0; root = a; return\nelseif fb == 0; root = b; return\nend\n\n% Verifica que la ra\u00edz est\u00e9 encerrada\nif fa * fb &gt; 0\n    error('La ra\u00edz no est\u00e1 encerrada en (a, b)')\nend\n\nx = (a + b) / 2;                       % Punto inicial: punto medio\n\nfor i = 1:30\n    fx = feval(func, x);               % Evaluar f(x)\n    if abs(fx) &lt; tol                   % Verifica si ya encontr\u00f3 la ra\u00edz\n        root = x; return\n    end\n\n    % Ajuste del intervalo usando bisecci\u00f3n\n    if fa * fx &lt; 0\n        b = x; fb = fx;\n    else\n        a = x; fa = fx;\n    end\n\n    dfx = feval(dfunc, x);             % Evaluar f'(x)\n    if abs(dfx) == 0                   % Evitar divisi\u00f3n por cero\n        dx = b - a;\n    else\n        dx = -fx / dfx;                % Paso de Newton-Raphson\n    end\n\n    x = x + dx;                        % Nueva estimaci\u00f3n\n\n    % Si la estimaci\u00f3n sale del intervalo, usar bisecci\u00f3n\n    if (x &lt; a) || (x &gt; b)\n        dx = (b - a) / 2;\n        x = a + dx;\n    end\n\n    % Verificaci\u00f3n de convergencia\n    if abs(dx) &lt; tol * max(abs(b), 1.0)\n        root = x; return\n    end\nend\n\nroot = NaN;                            % Si no converge en 30 iteraciones\nend\n</code></pre> <p>\u2b60 Volver al inicio</p>"},{"location":"newtonRaphson_sistema/","title":"Newton-Raphson para Sistemas de Ecuaciones","text":"newtonRaphson_sistema.m<pre><code>function root = newtonRaphson_sistema(func, x, tol)\n% M\u00e9todo de Newton-Raphson para encontrar la ra\u00edz de un sistema de\n% ecuaciones no lineales: f_i(x_1,x_2,...,x_n) = 0, para i = 1,2,...,n.\n% USO:\n%   root = newtonRaphson_sistema(func, x, tol)\n% ENTRADAS:\n%   func - funci\u00f3n manejable que retorna el vector [f1, f2, ..., fn]\n%   x    - vector columna con la estimaci\u00f3n inicial [x1; x2; ...; xn]\n%   tol  - tolerancia al error (opcional, por defecto 1.0e4 * eps)\n% SALIDA:\n%   root - vector soluci\u00f3n (aproximaci\u00f3n de la ra\u00edz)\nif nargin == 2; tol = 1.0e4 * eps; end             % Tolerancia por defecto\nif size(x,1) == 1; x = x'; end                     % Asegura que x sea columna\nfor i = 1:30                                       % M\u00e1ximo 30 iteraciones\n    [jac, f0] = jacobian(func, x);                % Calcula Jacobiana y f(x)\n    % Criterio de convergencia por magnitud de f(x)\n    if sqrt(dot(f0, f0) / length(x)) &lt; tol\n        root = x;\n        return\n    end\n    dx = jac \\ (-f0);                             % Resuelve J dx = -f\n    x = x + dx;                                   % Actualiza soluci\u00f3n\n    % Criterio de convergencia por cambio en x\n    if sqrt(dot(dx, dx) / length(x)) &lt; tol * max(abs(x), 1.0)\n        root = x;\n        return\n    end\nend\nerror('Muchas iteraciones: el m\u00e9todo no convergi\u00f3.');\nend\n</code></pre> <p>\u2b60 Volver al inicio</p>"},{"location":"newton_fractal/","title":"Fractal de Newton-Raphson","text":"<p>Este script genera un fractal en el plano complejo usando el m\u00e9todo de Newton-Raphson para encontrar las ra\u00edces de la funci\u00f3n:</p> \\[ f(z) = z^3 - 1 \\] <p>Cada punto se colorea seg\u00fan la ra\u00edz a la que converge, revelando las cuencas de atracci\u00f3n.</p>"},{"location":"newton_fractal/#codigo-en-matlab","title":"C\u00f3digo en MATLAB","text":"newton_fractal.m<pre><code>close all; clear all; clc;\n\n% Funci\u00f3n y derivada\nf  = @(z) z.^3 - 1;\nfp = @(z) 3*z.^2;\n\n% Ra\u00edces\nroot1 = 1;\nroot2 = -1/2 + 1i*sqrt(3)/2;\nroot3 = -1/2 - 1i*sqrt(3)/2;\n\n% Malla en el plano complejo\nnx = 1000; ny = 1000;\nxmin = -2; xmax = 2;\nymin = -2; ymax = 2;\n\nx = linspace(xmin, xmax, nx);\ny = linspace(ymin, ymax, ny);\n[X, Y] = meshgrid(x, y);\nZ = X + 1i*Y;\n\n% Iteraciones de Newton\nnit = 40;\nfor n = 1:nit\n    Z = Z - f(Z) ./ fp(Z);\nend\n\n% Clasificaci\u00f3n por ra\u00edz\neps = 0.001;\nZ1 = abs(Z - root1) &lt; eps;\nZ2 = abs(Z - root2) &lt; eps;\nZ3 = abs(Z - root3) &lt; eps;\nZ4 = ~(Z1 + Z2 + Z3); % No convergi\u00f3\n\n% Visualizaci\u00f3n\nfigure;\nmap = [1 0 0;   % rojo\n       0 1 0;   % verde\n       0 0 1;   % azul\n       0 0 0];  % negro\nZ = (Z1 + 2*Z2 + 3*Z3 + 4*Z4);\nimage([xmin xmax], [ymin ymax], Z);\ncolormap(map);\nset(gca, 'YDir', 'normal');\n\n% Etiquetas\naxis equal; axis tight;\nset(gca, 'XTick', linspace(xmin,xmax,5), 'YTick', linspace(ymin,xmax,5));\nxlabel('$x$', 'Interpreter', 'latex', 'FontSize', 14);\nylabel('$y$', 'Interpreter', 'latex', 'FontSize', 14);\ntitle('Fractal from $f(z)=z^3-1$', 'Interpreter', 'latex', 'FontSize', 16);\n</code></pre> <p>\u2b60 Volver al inicio</p>"},{"location":"newton_simple/","title":"Newton-Raphson Simple","text":"newton_simple.m<pre><code>function [root, numIter] = newton_simple(func, dfunc, x, tol)\n% Versi\u00f3n simple del m\u00e9todo de Newton-Raphson.\n% USO:\n%   [root, numIter] = newton_simple(func, dfunc, x, tol)\n% ENTRADAS:\n%   func  - funci\u00f3n manejable que eval\u00faa f(x)\n%   dfunc - funci\u00f3n manejable que eval\u00faa f'(x)\n%   x     - valor inicial (x0)\n%   tol   - tolerancia al error (opcional, por defecto 1.0e6*eps)\n% SALIDAS:\n%   root     - aproximaci\u00f3n de la ra\u00edz\n%   numIter  - n\u00famero de iteraciones realizadas\n\nif nargin &lt; 4; tol = 1.0e6 * eps; end    % Establecer tolerancia por defecto\nnumIter = 0;\nfor i = 1:50                   % M\u00e1ximo de 50 iteraciones\n    fx = feval(func, x);      % Evaluar funci\u00f3n\n    dfx = feval(dfunc, x);    % Evaluar derivada\n    if dfx == 0               % Evita divisi\u00f3n por cero\n        root = NaN; return\n    end\n    dx = -fx / dfx;           % Paso de Newton\n    x = x + dx;               % Actualiza estimaci\u00f3n\n    if abs(dx) &lt; tol          % Criterio de convergencia\n        root = x; numIter = i; return\n    end\nend\nroot = NaN;                   % No convergi\u00f3 en 50 iteraciones\nend\n</code></pre> <p>\u2b60 Volver al inicio</p>"}]}